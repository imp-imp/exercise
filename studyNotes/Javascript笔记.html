1Javascript的简单形式
    行内样式,内嵌样式和外部样式<script src="my.js"></script>中间不能填代码
    Javascript建议使用单引号
    // 1. 单行注释  ctrl + /
    /* 2. 多行注释  默认的快捷键 shift +  alt  + a
       2. 多行注释  vscode 中修改多行注释的快捷键:  ctrl + shift + /
    */
2JS输入输出语句
    这是一个输入框 prompt('请输入您的年龄');
    alert 弹出警示框 输出的 展示给用户的 alert('计算的结果是');
    console 控制台输出 给程序员测试用的 console.log('我是程序员能看到的');
    document.write 往网页写入 document.write('你猜我在哪？')

3变量,常量和标识符
    变量申明和赋值方式  let i = 100 也可以分开写,let i i=100
    可以申明多个变量 let a,b,c

    常量,语法 const PI=3.1415926   常量名建议全部大写,在JS中除了常规的常量外,有一些对象类型的数据我们也会声明为常量

    标识符
    1. 标识符只能含有字母、数字、下划线、$,且不能以数字开头
    2. 标识符不能是JS中的关键字和保留字,也不建议使用内置的函数或类名作为变量名
    3. 命名规范:
        - 通常会使用驼峰命名法
            - 首字母小写,每个单词开头大写
            - maxlength --> maxLength
            - borderleftwidth --> borderLeftWidth

        - 类名会使用大驼峰命名法
            - 首字母大写,每个单词开头大写
            - maxlength --> MaxLength

        - 常量的字母会全部大写
            - MAX_LENGTH
    
4数值
    JS的数值大小不能太大,不然会显示近似值
    Infinity 是一个特殊的数值表示无穷
    NaN 也是一个特殊的数值,表示非法的数值
    其他进制的数字:
        二进制 0b
        八进制 0o
        十六进制 0x
5类型检查
    typeof 运算符
    - typeof用来检查不同的值的类型
    - 它会根据不同的值返回不同的结果
    console.log(typeof a) // "number"
    console.log(typeof b) // "bigint"

6字符串(String)
    - 在JS中使用单引号或双引号来表示字符串
    - 转义字符 \
        \" --> "
        \' --> '
        \\ --> \
        \t --> 制表符
        \n --> 换行
    - 模板字符串
        - 使用反单引号` 来表示模板字符串
        - 模板字符串中可以嵌入变量 
        let name = "猪八戒"
        let str = `你好,${name}`
    - 使用typeof检查一个字符串时会返回 "string"
7其他数据类型
    布尔值(Boolean)
    - 布尔值主要用来进行逻辑判断
    - 布尔值只有两个true 和 false
    - 使用typeof检查一个布尔值时会返回 "boolean"

    空值 (Null)
    - 空值用来表示空对象
    - 空值只有一个 null
    - 使用typeof检查一个空值时会返回"object"
    - 使用typeof无法检查空值

    未定义(Undefined)
    - 当声明一个变量而没有赋值时,它的值就是Undefined
    - Undefined类型的值只有一个就是 undefined
    - 使用typeof检查一个Undefined类型的值时,会返回 "undefined"

    符号(Symbol)
    - 用来创建一个唯一的标识    
    - 使用typeof检查符号时会返回 "symbol"

    JS中原始值一共有七种
    1.Number
    2.BigInt
    3.String
    4.Boolean
    5.Null
    6.Undefined
    7.Symbol
    七种原始值是构成各种数据的基石
        原始值在JS中是不可变类型,一旦创建就不能修改

8类型转换
    转换为字符串
    1.调用toString()方法将其他类型转换为字符串
        - 调用xxx的yyy方法
            --> xxx.yyy()
        - 由于null和undefined中没有toString()
            所以对这两个东西调用toString()时会报错
    2.调用String()函数将其他类型转换为字符串
        - 调用xxx函数
            --> xxx()
        - 原理:
            对于拥有toString()方法的值调用String()函数时,
                实际上就是在调用toString()方法
            对于null,则直接转换为"null"
            对于undefined,直接转换为"undefined"
    
    将其他的数据类型转换为数值
    1.使用Number()函数来将其他类型转换为数值
        转换的情况:
            - 字符串:
                - 如果字符串是一个合法的数字,则会自动转换为对应的数字
                - 如果字符串不是合法数字,则转换为NaN
                - 如果字符串是空串或纯空格的字符串,则转换为0
            - 布尔值:
                - true转换为1,false转换为0
            - null 转换为 0
            - undefined 转换为 NaN

    专门用来将字符串转换为数值的两个方法           
        parseInt() —— 将一个字符串转换为一个整数
            - 解析时,会自左向右读取一个字符串,直到读取到字符串中所有的有效的整数
            - 也可以使用parseInt()来对一个数字进行取整
        parseFloat() —— 将一个字符串转换为浮点数 
            - 解析时,会自左向右读取一个字符串,直到读取到字符串中所有的有效的小数

    使用Boolean()函数来将其他类型转换为布尔值
        - 转换的情况:
            数字:
                - 0 和 NaN 转换为false
                - 其余是true

            字符串:
                - 空串 转换为 false
                - 其余是true

            null和undefined 都转换为 false

            对象:对象会转换为true

        - 所有表示空性的没有的错误的值都会转换为false:
            0、NaN、空串、null、undefined、false


        - 类型转换总结
        转换为字符串
            显式转换
                String()
            隐式转换
                + ""
        转换为数值
            显式转换
                Number()
            隐式转换
                +
        转换为布尔值
            显式转换
                Boolean()
            隐式转换
                !!

9运算符(操作符)
    - 运算符可以用来对一个或多个操作数(值)进行运算
    1- 算术运算符:
        + 加法运算符
        - 减法运算符
        * 乘法运算符
        / 除法运算符
        ** 幂运算
        % 模运算,两个数相除取余数

    - 注意:
        - 算术运算时,除了字符串的加法,
            其他运算的操作数是非数值时,都会转换为数值然后再运算

        当任意一个值和字符串做加法运算时,它会先将其他值转换为字符串,
        然后再做拼串的操作
    可以利用这一特点来完成类型转换
        可以通过为任意类型 + 一个空串的形式来将其转换为字符串
            其原理和String()函数相同,但使用起来更加简洁
    
    2赋值运算符用来将一个值赋值给一个变量
    =
        - 将符号右侧的值赋值给左侧的变量
    ??=
        - 空赋值
        - 只有当变量的值为null或undefined时才会对变量进行赋值
    +=
        - a += n 等价于 a = a + n
    -=
        - a -= n 等价于 a = a - n
    *=
        - a *= n 等价于 a = a * n
    /=
        - a /= n 等价于 a = a / n
    %=
        - a %= n 等价于 a = a % n
    **=
        - a **= n 等价于 a = a ** n

    3一元的±
    + 正号
        - 不会改变数值的符号
    - 负号
        - 可以对数值进行符号位取反
    
    当我们对非数值类型进行正负运算时,会先将其转换为数值然后再运算

    4++ 自增运算符
        - ++ 使用后会使得原来的变量立刻增加1
        - 自增分为前自增(++a)和后自增(a++)
        - 无论是++a还是a++都会使原变量立刻增加1
        - 不同的是++a和a++所返回的值不同
            a++ 是自增前的值 旧值
            ++a 是自增后的值 新值

    5-- 自减运算符
        - 使用后会使得原来的变量立刻减小1
        - 自减分为前自减(--a)和后自减(a--)
        - 无论是--a还是a--都会使原变量立刻减少1
        - 不同的是--a和a--的值不同
            --a 是新值
            a-- 是旧值
    
    6逻辑运算符
     ! 逻辑非
    - ! 可以用来对一个值进行非运算
    - 它可以对一个布尔值进行取反操作
        true --> false
        false --> true
    - 如果对一个非布尔值进行取反,它会先将其转换为布尔值然后再取反
        可以利用这个特点将其他类型转换为布尔值
    
    && 逻辑与
        - 可以对两个值进行与运算
        - 当&&左右都为true时,则返回true,否则返回false
        - 与运算是短路的与,如果第一个值为false,则不看第二个值
        - 与运算是找false的,如果找到false则直接返回,没有false才会返回true
        - 对于非布尔值进行与运算,它会转换为布尔值然后运算
            但是最终会返回原值
            - 如果第一个值为false,则直接返回第一个值
                如果第一个值为true,则返回第二个值

    || 逻辑或
        - 可以对两个值进行或运算
        - 当||左右有true时,则返回true,否则返回false
        - 或运算也是短路的或,如果第一个值为true,则不看第二个值
        - 或运算是找true,如果找到true则直接返回,没有true才会返回false
        - 对于非布尔值或运算,它会转换为布尔值然后运算
            但是最终会返回原值
            - 如果第一个值为true,则返回第一个
                如果第一个值为false,则返回第二个

    7关系运算符
        - 关系运算符用来检查两个值之间的关系是否成立
            成立返回true,不成立返回false
        >
            - 用来检查左值是否大于右值
        >=
            - 用来检查左值是否大于或等于右值
        <
            - 用来检查左值是否小于右值
        <=
            - 用来检查左值是否小于或等于右值

    注意:
        当对非数值进行关系运算时,它会先将前转换为数值然后再比较 
        当关系运算符的两端是两个字符串,它不会将字符串转换为数值,
            而是逐位的比较字符的Unicode编码   
            利用这个特点可以对字符串按照字母排序  
        注意比较两个字符串格式的数字时一定要进行类型转换 

    8相等运算符
        ==
        - 相等运算符,用来比较两个值是否相等
        - 使用相等运算符比较两个不同类型的值时,
            它会将其转换为相同的类型(通常转换为数值)然后再比较
            类型转换后值相同也会返回true
        - null和undefined进行相等比较时会返回true
        - NaN不和任何值相等,包括它自身
    ===
        - 全等运算符,用来比较两个值是否全等
        - 它不会进行自动的类型转换,如果两个值的类型不同直接返回false
        - null和undefined进行全等比较时会返回false

    !=
        - 不等,用来检查两个值是否不相等
        - 会自动的进行类型转换
    !==
        - 不全等,比较两个值是否不全等
        - 不和自动的类型转换

    9条件运算符
        条件表达式 ? 表达式1 : 表达式2
        - 执行顺序:
            条件运算符在执行时,会先对条件表达式进行求值判断,
                如果结果为true,则执行表达式1
                如果结果为false,则执行表达式2
    
    10优先级不确定直接加()

10代码块
    用{}区分代码块,let声明的变量有作用域,var没有作用域。没有作用域的变量可以在代码块外部访问到。
    
11流程控制语句
    流程控制语句可以用来改变程序执行的顺序
    1. 条件判断语句
    2. 条件分支语句
    3. 循环语句

    prompt() 可以用来获取用户输入的内容
    它会将用户输入的内容以字符串的形式返回,可以通过变量来接收

    条件判断语句 if
        语法:
            if(条件表达式){
                语句...
            }
        - 执行流程
        if语句在执行会先对if后的条件表达式进行求值判断,
            如果结果为true,则执行if后的语句
            如果为false则不执行

        if语句只会控制紧随其后其后的那一行代码,如果希望可以控制多行代码,可以使用{}将语句扩起来
            最佳实践:即使if后只有1行代码,我们也应该编写代码块,这样结构会更加的清晰

        如果if后的添加表达式不是布尔值,会转换为布尔值然后再运算
    
    if-else语句
        - 语法:
            if(条件表达式){
                语句...
            }else{
                语句...
            }

            if-else语句
            - 语法:
                if(条件表达式){
                    语句...
                }else{
                    语句...
                }

        - 执行流程:
            if-else执行时,先对条件表达式进行求值判断,
                如果结果为true 则执行if后的语句
                如果结果为false 则执行else后的语句

    if-else if-else语句:
    - 语法:
        if(条件表达式){
            语句...
        }else if(条件表达式){
            语句...
        }else if(条件表达式){
            语句...
        }else if(条件表达式){
            语句...
        }else{
            语句...
        }
    - 执行流程:
        if-else if-else语句,会自上向下依次对if后的条件表达式进行求值判断,
            如果条件表达式结果为true,则执行当前if后的语句,执行完毕语句结束
            如果条件表达式结果为false,则继续向下判断,直到找到true为止
            如果所有的条件表达式都是false,则执行else后的语句

    注意:
        if-else if-else语句中只会有一个代码块被执行,
            一旦有执行的代码块,下边的条件都不会在继续判断了
            所以一定要注意,条件的编写顺序

    switch语句
    - 语法:
        switch(表达式){
            case 表达式:
                代码...
                break
            case 表达式:
                代码...
                break
            case 表达式:
                代码...
                break
            case 表达式:
                代码...
                break
            default:
                代码...
                break
        }

    - 执行的流程
        switch语句在执行时,会依次将switch后的表达式和case后的表达式进行全等比较
            如果比较结果为true,则自当前case处开始执行代码
            如果比较结果为false,则继续比较其他case后的表达式,直到找到true为止
            如果所有的比较都是false,则执行default后的语句

    - 注意:
        当比较结果为true时,会从当前case处开始执行代码
            也就是说case是代码执行的起始位置
        这就意味着只要是当前case后的代码,都会执行
        可以使用break来避免执行其他的case

    - 总结
        switch语句和if语句的功能是重复,switch能做的事if也能做,反之亦然。
            它们最大的不同在于,switch在多个全等判断时,结构比较清晰
12循环语句
    - 通过循环语句可以使指定的代码反复执行
    - JS中一共有三种循环语句
        while语句
        do-while语句
        for语句

        通常编写一个循环,要有三个要件
        1.初始化表达式(初始化变量)
        2.条件表达式(设置循环运行的条件)
        3.更新表单式(修改初始化变量)

    - while语句
        - 语法:
            while(条件表达式){
                语句...
            }

    - 执行流程:
        while语句在执行时,会先对条件表达式进行判断,
            如果结果为true,则执行循环体,执行完毕,继续判断
            如果为true,则再次执行循环体,执行完毕,继续判断,如此重复
            知道条件表达式结果为false时,循环结束

    do-while循环
        - 语法:
            do{
                语句...
            }while(条件表达式)

        - 执行顺序:
            do-while语句在执行时,会先执行do后的循环体,
                执行完毕后,会对while后的条件表达式进行判断
                如果为false,则循环终止
                如果为true,则继续执行循环体,以此类推

            和while的区别:
                while语句是先判断再执行
                do-while语句是先执行再判断

        实质的区别:
            do-while语句可以确保循环至少执行一次


    for循环
        - for循环和while没有本质区别,都是用来反复执行代码
        - 不同点就是语法结构,for循环更加清晰
        - 语法:
            for(①初始化表达式; ②条件表达式; ④更新表达式){
                ③语句...
            }

        - 执行流程:
            ① 执行初始化表达式,初始化变量
            ② 执行条件表达式,判断循环是否执行(true执行,false终止)
            ③ 判断结果为true,则执行循环体
            ④ 执行更新表达式,对初始化变量进行修改
            ⑤ 重复②,知道判断为false为止

        - 初始化表达式,在循环的整个的生命周期中只会执行1次
        - for循环中的三个表达式都可以省略
        - 使用let在for循环的()中声明的变量是局部变量,只能在for循环内部访问
            使用var在for循环的()中声明的变量可以在for循环的外部访问
        - 创建死循环的方式:
            while(1){}
            for(;;){}

    break和continue
    - break
        - break用来终止switch和循环语句
        - break执行后,当前的switch或循环会立刻停止
        - break会终止离他最近的循环

    - continue
        - continue用来跳过当次循环

13对象
    1对象的简介
        - 对象是JS中的一种复合数据类型,
            它相当于一个容器,在对象中可以存储各种不同类型数据

        原始值只能用来表示一些简单的数据,不能表示复杂数据

        比如:现在需要在程序中表示一个人的信息
        对象中可以存储多个各种类型的数据
        对象中存储的数据,我们称为属性

        创建对象
        let obj=object() 第一种方式
        let obj={}
    
    2对象字面量
        - 可以直接使用{} 来创建对象
        - 使用{}所创建的对象,可以直接向对象中添加属性
        - 语法:
            {
                属性名:属性值,
                [属性名]:属性值,
            }
            
        向对象中添加属性:
            对象.属性名 = 属性值

        向对象中修改属性:
        对象.属性名 = 属性值

        向对象中删除属性:
        delete 对象.属性名

        读取对象中的属性
            对象.属性名
            - 如果读取的是一个对象中没有的属性
                不会报错而是返回undefined

    3属性名
        - 通常属性名就是一个字符串,所以属性名可以是任何值,没有什么特殊要求
            但是如果你的属性名太特殊了,不能直接使用,需要使用[]来设置
            虽然如此,但是我们还是强烈建议属性名也按照标识符的规范命名

        - 也可以使用符号(symbol)作为属性名,来添加属性
            获取这种属性时,也必须使用symbol
            使用symbol添加的属性,通常是那些不希望被外界访问的属性
            let mySymbol = Symbol()
            let newSymbol = Symbol()
            使用symbol作为属性名
            obj[mySymbol] = "通过symbol添加的属性"

        - 使用[]去操作属性时,可以使用变量

    4属性值
        -使用typeof检查一个对象时,会返回object
        in 运算符
        - 用来检查对象中是否含有某个属性
        - 语法 属性名 in obj
        - 如果有返回true,没有返回false

    5枚举属性,指将对象中的所有的属性全部获取

            for-in语句
            - 语法:
                for(let propName in 对象){
                    语句...
                }

            - for-in的循环体会执行多次,有几个属性就会执行几次,
                每次执行时,都会将一个属性名赋值给我们所定义的变量
            
            - 注意:并不是所有的属性都可以枚举,比如 使用符号添加的属性
        let obj = {
            name:'孙悟空',
            age:18,
            gender:"男",
            address:"花果山",
            [Symbol()]:"测试的属性" // 符号添加的属性是不能枚举
        }

        for(let propName in obj){
            console.log(propName, obj[propName])
        }


        修改对象
        - 修改对象时,如果有其他变量指向该对象
            则所有指向该对象的变量都会受到影响

        修改变量
        - 修改变量时,只会影响当前的变量

        在使用变量存储对象时,很容易因为改变变量指向的对象,提高代码的复杂度
        所以通常情况下,声明存储对象的变量时会使用const

        注意:
        const只是禁止变量被重新赋值,对对象的修改没有任何影响


14函数(Function)
    1函数简介
        - 函数也是一个对象
        - 它具有其他对象所有的功能
        - 函数中可以存储代码,且可以在需要时调用这些代码

        语法:
        function 函数名(){
            语句...
        }

        调用函数:
        - 调用函数就是执行函数中存储的代码
        - 语法:
            函数对象()

        使用typeof检查函数对象时会返回function

    2函数的定义方式:
        1.函数声明
            function 函数名(){
                语句...
            }

        2.函数表达式
            const 变量 = function(){
                语句...
            }

        3.箭头函数
            () => {
                语句...
            }


    3形式参数
            - 在定义函数时,可以在函数中指定数量不等的形式参数(形参)
            - 在函数中定义形参,就相当于在函数内部声明了对应的变量但是没有赋值

        实际参数
            - 在调用函数时,可以在函数的()传递数量不等的实参
            - 实参会赋值给其对应的形参
            - 参数:
                1.如果实参和形参数量相同,则对应的实参赋值给对应的形参
                2.如果实参多余形参,则多余的实参不会使用
                3.如果形参多余实参,则多余的形参为undefined

            - 参数的类型
                - JS中不会检查参数的类型,可以传递任何类型的值作为参数

        1.函数声明
                function 函数名([参数]){
                    语句...
                }

        2.函数表达式
            const 变量 = function([参数]){
                语句...
            }

        3.箭头函数
            ([参数]) => {
                语句...
            }

        定义参数时,可以为参数指定默认值
        默认值,会在没有对应实参时生效
        const fn3 = (a=10, b=20, c=30) => {
            console.log("a =", a);
            console.log("b =", b);
            console.log("c =", c);
        }
    
    4箭头函数
        当箭头函数中只有一个参数时,可以省略()
        const fn2 = a => {
            console.log("a =", a);
        }

        const sum = (a, b) => a + b    箭头函数的返回值可以直接写在箭头后
        const fn = () => ({name:"孙悟空"})      如果直接在箭头后设置对象字面量为返回值时,对象字面量必须使用()括起来

    5对象作为函数参数
        function fn(a){
            console.log("a =", a)
            console.log(a.name)

            a = {} // 修改变量时,只会影响当前的变量
            a.name = "猪八戒" // 修改对象时,如果有其他变量指向该对象则所有指向该对象的变量都会受到影响
            console.log(a)
        }

        对象可以作为参数传递
            let obj = {name:"孙悟空"}

        传递实参时,传递并不是变量本身,而是变量中存储的值
            fn(obj)

            console.log(obj)

            let obj2 = {name:"沙和尚"}
        
        函数每次调用,都会重新创建默认值
        function fn2(a = {name:"沙和尚"}){
            console.log("a =", a)
            a.name = "唐僧"
            console.log("a =", a)
        }

        fn2() // 沙和尚 唐僧
        fn2() // 沙和尚 唐僧 or 唐僧 唐僧
    
    6匿名函数
        function fn(a){
            console.log("a =", a)
            a()
        }

        function fn2(){
            console.log("我是fn2")
        }

        fn(fn2) 输出效果就是a=fn2这个函数,“我是fn2”
        以下同理

        fn(function(){
            console.log("我是匿名函数~")
        })  

        fn(()=>console.log("我是箭头函数"))

    7函数的返回值
        在函数中,可以通过return关键字来指定函数的返回值
        返回值就是函数的执行结果,函数调用完毕返回值便会作为结果返回

        任何值都可以作为返回值使用(包括对象和函数之类)
        如果return后不跟任何值,则相当于返回undefined
        如果不写return,那么函数的返回值依然是undefined

        return一执行函数立即结束

    8作用域(scope)
        - 作用域指的是一个变量的可见区域
        - 作用域有两种:
            全局作用域
                - 全局作用域在网页运行时创建,在网页关闭时消耗
                - 所有直接编写到script标签中的代码都位于全局作用域中
                - 全局作用域中的变量是全局变量,可以在任意位置访问

            局部作用域
                - 块作用域
                    - 块作用域是一种局部作用域
                    - 块作用域在代码块执行时创建,代码块执行完毕它就销毁
                    - 在块作用域中声明的变量是局部变量,只能在块内部访问,外部无法访问
    9函数作用域
        - 函数作用域也是一种局部作用域
        - 函数作用域在函数调用时产生,调用结束后销毁
        - 函数每次调用都会产生一个全新的函数作用域
        - 在函数中定义的变量是局部变量,只能在函数内部访问,外部无法访问

    10作用域链
        - 当我们使用一个变量时,JS解释器会优先在当前作用域中寻找变量,
            如果找到了则直接使用
            如果没找到,则去上一层作用域中寻找,找到了则使用
            如果没找到,则继续去上一层寻找,以此类推
            如果一直到全局作用域都没找到,则报错 xxx is not defined

    11window对象
        - 在浏览器中,浏览器为我们提供了一个window对象,可以直接访问
        - window对象代表的是浏览器窗口,通过该对象可以对浏览器窗口进行各种操作
            除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
        - window对象的属性可以通过window对象访问,也可以直接访问
        - 函数就可以认为是window对象的方法

        window.a = 10 // 向window对象中添加的属性会自动成为全局变量
        // console.log(a)

        var 用来声明变量,作用和let相同,但是var不具有块作用域
        - 在全局中使用var声明的变量,都会作为window对象的属性保存
        - 使用function声明的函数,都会作为window的方法保存
        - 使用let声明的变量不会存储在window对象中,而存在一个秘密的小地方(无法访问)
        - var虽然没有块作用域,但有函数作用域

    12变量的提升
    - 使用var声明的变量,它会在所有代码执行前被声明
        所以我们可以在变量声明前就访问变量

    函数的提升
    - 使用函数声明创建的函数,会在其他代码执行前被创建
        所以我们可以在函数声明前调用函数

    let声明的变量实际也会提升,但是在赋值之前解释器禁止对该变量的访问

    13断点
        debugger关键字可以让程序运行到此处的时候停下来

    14立即执行函数
        在开发中应该尽量减少直接在全局作用域中编写代码！
        所以我们的代码要尽量编写的局部作用域
        如果使用let声明的变量,可以使用{}来创建块作用域

        立即执行函数(IIFE)
        - 立即是一个匿名的函数,并它只会调用一次
        - 可以利用IIFE来创建一个一次性的函数作用域,避免变量冲突的问题
        - 两个匿名函数之间函数之间用;隔开

        (function(){
            let a = 10
            console.log(111)
        }());

        (function(){
            let a = 20
            console.log(222)
        }())

    15this以及箭头函数的this
            - 函数在执行时,JS解析器每次都会传递进一个隐含的参数
            - 这个参数就叫做 this
            - this会指向一个对象
                - this所指向的对象会根据函数调用方式的不同而不同
                    1.以函数形式调用时,this指向的是window
                    2.以方法的形式调用时,this指向的是调用方法的对象
                    ...

            - 通过this可以在方法中引用调用方法的对象

        箭头函数:
            ([参数]) => 返回值

            例子:
            无参箭头函数:() => 返回值
            一个参数的:a => 返回值
            多个参数的:(a, b) => 返回值

            只有一个语句的函数:() => 返回值
            只返回一个对象的函数:() => ({...})
            有多行语句的函数:() => {
                ....    
                return 返回值
            }

        箭头函数没有自己的this,它的this有外层作用域决定,箭头函数的this和它的调用方式无关


        注释:一般函数的this指向的就是调用的对象,比如在全局中或者块作用域中(包含函数作用域)fn()调用this就是window.fn(),this指向的就是window
            如果在方法中调用this,比如obj.test(),this就是指向的obj。
            箭头函数的this等于外层函数的this指向的对象,如果外层也是箭头函数的话,再往外层找。

    16严格模式
        JS运行代码的模式有两种:
        - 正常模式
            - 默认情况下代码都运行在正常模式中,
                在正常模式,语法检查并不严格
                它的原则是:能不报错的地方尽量不报错
            - 这种处理方式导致代码的运行性能较差

        - 严格模式
            - 在严格模式下,语法检查变得严格
                1.禁止一些语法
                2.更容易报错
                3.提升了性能

        - 在开发中,应该尽量使用严格模式,
            这样可以将一些隐藏的问题消灭在萌芽阶段,
                同时也能提升代码的运行性能

        "use strict" // 全局的严格模式
       
        function fn(){
            "use strict" // 函数的严格的模式
        }
    
    17高阶函数
        - 如果一个函数的参数或返回值是函数,则这个函数就称为高阶函数
        - 为什么要将函数作为参数传递？(回调函数有什么作用？)
            - 将函数作为参数,意味着可以对另一个函数动态的传递代码
        我们这种定义回调函数的形式比较少见,通常回调函数都是匿名函数

    18闭包
        闭包就是能访问到外部函数作用域中变量的函数
        什么时候使用:
        当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包
        构成闭包的要件:
        1. 函数的嵌套
        2. 内部函数要引用外部函数中的变量
        3. 内部函数要作为返回值返回
        
        闭包的生命周期:
        1. 闭包在外部函数调用时产生,外部函数每次调用都会产生一个全新的闭包
        2. 在内部函数丢失时销毁(内部函数被垃圾回收了,闭包才会消失)

        注意事项:
        闭包主要用来隐藏一些不希望被外部访问的内容,
            这就意味着闭包需要占用一定的内存空间

        相较于类来说,闭包比较浪费内存空间(类可以使用原型而闭包不能),
            需要执行次数较少时,使用闭包
            需要大量创建实例时,使用类

    19递归
        - 调用自身的函数称为递归函数
        - 递归的作用和循环是基本一致

        递归的核心思想就是将一个大的问题拆分为一个一个小的问题,小的问题解决了,大的问题也就解决了

        编写递归函数,一定要包含两个要件:
            1.基线条件 ——  递归的终止条件
            2.递归条件 ——  如何对问题进行拆分

        递归的作用和循环是一致的,不同点在于,递归思路的比较清晰简洁,循环的执行性能比较好
            在开发中,一般的问题都可以通过循环解决,也是尽量去使用循环,少用递归
            只在一些使用循环解决比较麻烦的场景下,才使用递归

    20可变参数
        arguments
        - arguments是函数中又一个隐含参数
        - arguments是一个类数组对象(伪数组)
            和数组相似,可以通过索引来读取元素,也可以通过for循环变量,但是它不是一个数组对象,不能调用数组的方法
        - arguments用来存储函数的实参,
            无论用户是否定义形参,实参都会存储到arguments对象中
            可以通过该对象直接访问实参
        
        可变参数,在定义函数时可以将参数指定为可变参数
            - 可变参数可以接收任意数量实参,并将他们统一存储到一个数组中返回
            - 可变参数的作用和arguments基本是一致,但是也具有一些不同点:
                1. 可变参数的名字可以自己指定
                2. 可变参数就是一个数组,可以直接使用数组的方法
                3. 可变参数可以配合其他参数一起使用
        语法:...形参名(和扩展符一样都是三个.)



15面向对象
    1创建类
        使用Object创建对象的问题:
        1. 无法区分出不同类型的对象
        2. 不方便批量创建对象

        在JS中可以通过类(class)来解决这个问题:
        1. 类是对象模板,可以将对象中的属性和方法直接定义在类中
            定义后,就可以直接通过类来创建对象
        2. 通过同一个类创建的对象,我们称为同类对象
            可以使用instanceof来检查一个对象是否是由某个类创建
            如果某个对象是由某个类所创建,则我们称该对象是这个类的实例

        语法:
        class 类名 {} // 类名要使用大驼峰命名
        const 类名 = class {}  
        class Person{
        }

        通过类创建对象
        new 类()
        const p1 = new Person() // 调用构造函数创建对象

    2类的属性
        类是创建对象的模板,要创建第一件事就是定义类
        类的代码块,默认就是严格模式,
        类的代码块是用来设置对象的属性的,不是什么代码都能写
        class Person{
            name = "孙悟空" // Person的实例属性name p1.name
            age = 18       // 实例属性只能通过实例访问 p1.age
            static test = "test静态属性" // 使用static声明的属性,是静态属性(类属性) Person.test
            static hh = "静态属性"   // 静态属性只能通过类去访问 Person.hh
        }

    3类的方法
        class Person{
            name = "孙悟空"
            // sayHello = function(){
            // } // 添加方法的一种方式
            sayHello(){
                console.log('大家好,我是' + this.name)
            } // 添加方法(实例方法) 实例方法中this就是当前实例
            static test(){
                console.log("我是静态方法", this)
            } // 静态方法(类方法) 通过类来调用 静态方法中this指向的是当前类
        }
    
    4构造函数
        在类中可以添加一个特殊的方法constructor
        该方法我们称为构造函数(构造方法)
        构造函数会在我们调用类创建对象时执行
        可以在构造函数中,为实例属性进行赋值
        在构造函数中,this表示当前所创建的对象
        class Person{
            constructor(name, age, gender){
                console.log("构造函数执行了~", name, age, gender)
                this.name = name
                this.age = age
                this.gender = gender  }}
      
    5面向对象的三大特点:
        封装 —— 安全性
        继承 —— 扩展性
        多态 —— 灵活性

        1.封装
            - 对象就是一个用来存储不同属性的容器
            - 对象不仅存储属性,还要负责数据的安全
            - 直接添加到对象中的属性,并不安全,因为它们可以被任意的修改
            - 如何确保数据的安全:
                1.私有化数据
                    - 将需要保护的数据设置为私有,只能在类内部使用
                2.提供setter和getter方法来开放对数据的操作
                    - 属性设置私有,通过getter setter方法操作属性带来的好处
                        1. 可以控制属性的读写权限
                        2. 可以在方法中对属性的值进行验证

            - 封装主要用来保证数据的安全
            - 实现封装的方式:
                1.属性私有化 加#
                2.通过getter和setter方法来操作属性
                    get 属性名(){
                        return this.#属性
                    }

                    set 属性名(参数){
                        this.#属性 = 参数
                    }
            举例:
            class Person {
                // #address = "花果山" // 实例使用#开头就变成了私有属性,私有属性只能在类内部访问
                #name
                #age
                #gender
                constructor(name, age, gender) {
                    this.#name = name
                    this.#age = age
                    this.#gender = gender
                }
                sayHello() {
                    console.log(this.#name)
                }
                // getter方法,用来读取属性
                getName(){
                    return this.#name
                }
                // setter方法,用来设置属性
                setName(name){
                    this.#name = name
                }
                getAge(){
                    return this.#age
                }
                setAge(age){
                    if(age >= 0){
                        this.#age = age
                    }}

                get gender(){
                    return this.#gender
                }

                set gender(gender){
                    this.#gender = gender
                }}
        2多态
            - 在JS中不会检查参数的类型,所以这就意味着任何数据都可以作为参数传递
            - 要调用某个函数,无需指定的类型,只要对象满足某些条件即可
            - 如果一个东西走路像鸭子,叫起来像鸭子,那么它就是鸭子
            - 多态为我们提供了灵活性

        3继承
        - 可以通过extends关键来完成继承
                - 当一个类继承另一个类时,就相当于将另一个类中的代码复制到了当前类中(简单理解)
                - 继承发生时,被继承的类称为 父类(超类),继承的类称为 子类
                - 通过继承可以减少重复的代码,并且可以在不修改一个类的前提对其进行扩展
        
        - 通过继承可以在不修改一个类的情况下对其进行扩展
        - OCP 开闭原则
            - 程序应该对修改关闭,对扩展开放
        举例:
            class Animal{
                constructor(name){
                    this.name = name
                }
            sayHello(){
                    console.log("动物在叫~")
                }}

            class Dog extends Animal{
                // 在子类中,可以通过创建同名方法来重写父类的方法
                sayHello(){
                    console.log("汪汪汪")
                }}

            class Cat extends Animal{
                // 重写构造函数
                constructor(name, age){
                    // 重写构造函数时,构造函数的第一行代码必须为super()
                    super(name) // 调用父类的构造函数
                    this.age = age // 新增年龄属性
                }
    
                sayHello(){
                    // 调用一下父类的sayHello
                    super.sayHello() // 在方法中可以使用super来引用父类的方法
                    console.log("喵喵喵")
                }}

    6对象的结构
        对象中存储属性的区域实际有两个:
            1. 对象自身
                - 直接通过对象所添加的属性,位于对象自身中
                - 在类中通过 x = y 的形式添加的属性,位于对象自身中

            2. 原型对象(prototype)
                - 对象中还有一些内容,会存储到其他的对象里(原型对象)
                - 在对象中会有一个属性用来存储原型对象,这个属性叫做__proto__
                - 原型对象也负责为对象存储属性,
                    当我们访问对象中的属性时,会优先访问对象自身的属性,
                    对象自身不包含该属性时,才会去原型对象中寻找
                - 会添加到原型对象中的情况:
                    1. 在类中通过xxx(){}方式添加的方法,位于原型中
                    2. 主动向原型中添加的属性或方法

    7原型对象
        访问一个对象的原型对象
        对象.__proto__
        Object.getPrototypeOf(对象)

        原型对象中的数据:
            1. 对象中的数据(属性、方法等)
            2. constructor (对象的构造函数)

        注意:
            原型对象也有原型,这样就构成了一条原型链,根据对象的复杂程度不同,原型链的长度也不同
                p对象的原型链:p对象 --> 原型 --> 原型 --> null
                obj对象的原型链:obj对象 --> 原型 --> null

            原型链:
                - 读取对象属性时,会优先对象自身属性,
                    如果对象中有,则使用,没有则去对象的原型中寻找
                    如果原型中有,则使用,没有则去原型的原型中寻找
                    直到找到Object对象的原型(Object的原型没有原型(为null))
                        如果依然没有找到,则返回undefined

                - 作用域链,是找变量的链,找不到会报错
                - 原型链,是找属性的链,找不到会返回undefined

        所有的同类型对象它们的原型对象都是同一个,
        也就意味着,同类型对象的原型链是一样的

        原型的作用:
            原型就相当于是一个公共的区域,可以被所有该类实例访问,可以将该类实例中,所有的公共属性(方法)统一存储到原型中,这样我们只需要创建一个属性,即可被所有实例访问

        JS中继承就是通过原型来实现的,当继承时,子类的原型就是一个父类的实例

        在对象中有些值是对象独有的,像属性(name,age,gender)每个对象都应该有自己值,但是有些值对于每个对象来说都是一样的,像各种方法,对于一样的值没必要重复的创建

        大部分情况下,我们是不需要修改原型对象
            注意:
                千万不要通过类的实例去修改原型
                    1. 通过一个对象影响所有同类对象,这么做不合适
                    2. 修改原型先得创建实例,麻烦
                    3. 危险

        处理通过__proto__能访问对象的原型外,还可以通过类的prototype属性,来访问实例的原型。修改原型时,最好通过通过类去修改
            好处:
                1. 一修改就是修改所有实例的原型
                2. 无需创建实例即可完成对类的修改

            原则:
                1. 原型尽量不要手动改
                2. 要改也不要通过实例对象去改
                3. 通过 类.prototype 属性去修改
                4. 最好不要直接给prototype去赋值

        通过对象修改原型,向原型中添加方法,修改后所有同类实例都能访问该方法 不要这么做
        p.__proto__ = new Dog() // 直接为对象赋值了一个新的原型 不要这么做
    
    8instanceof和hasOwn
        instanceof 用来检查一个对象是否是一个类的实例
        - instanceof检查的是对象的原型链上是否有该类实例,只要原型链上有该类实例,就会返回true
        - dog -> Animal的实例 -> Object实例 -> Object原型
        - Object是所有对象的原型,所以任何和对象和Object进行instanceof运算都会返回true
       
        in  - 使用in运算符检查属性时,无论属性在对象自身还是在原型中,都会返回true

        对象.hasOwnProperty(属性名) (不推荐使用)
            - 用来检查一个对象的自身是否含有某个属性

        Object.hasOwn(对象, 属性名) (推荐使用)
            - 用来检查一个对象的自身是否含有某个属性

    9旧类
        早期JS中,直接通过函数来定义类
        - 一个函数如果直接调用 xxx() 那么这个函数就是一个普通函数
        - 一个函数如果通过new调用 new xxx() 那么这个函数就是一个构造函数

    10new运算符
        new运算符是创建对象时要使用的运算符
        - 使用new时,到底发生了哪些事情:
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new
        - 当使用new去调用一个函数时,这个函数将会作为构造函数调用,
            使用new调用函数时,将会发生这些事:
            1. 创建一个普通的JS对象(Object对象 {}), 为了方便,称其为新对象
            2. 将构造函数的prototype属性设置为新对象的原型
            3. 使用实参来执行构造函数,并且将新对象设置为函数中的this
            4. 如果构造函数返回的是一个非原始值,则该值会作为new运算的返回值返回(千万不要这么做)
                如果构造函数的返回值是一个原始值或者没有指定返回值,则新的对象将会作为返回值返回
                通常不会为构造函数指定返回值

   

16数组(Array)
    1数组简介
        - 数组也是一种复合数据类型,在数组可以存储多个不同类型的数据
        - 数组中存储的是有序的数据,数组中的每个数据都有一个唯一的索引
            可以通过索引来操作获取数据
        - 数组中存储的数据叫做元素
        - 索引(index)是一组大于0的整数
        - 创建数组
            通过Array()来创建数组,也可以通过[]来创建数组
            const arr = new Array()       
        - 向数组中添加元素
            语法:
                数组[索引] = 元素

        - 读取数组中的元素
            语法:
                数组[索引]
                - 如果读取了一个不存在的元素,不好报错而是返回undefined

        - length
            - 获取数组的长度
            - 获取的实际值就是数组的最大索引 + 1
            - 向数组最后添加元素:
                数组[数组.length] = 元素
            - length是可以修改的,被指定了length之后,多余的元素将被剔除

    2遍历数组
        for-of语句可以用来遍历可迭代对象

        语法:
            for(变量 of 可迭代的对象){
                语句...
            }

        执行流程:
            for-of的循环体会执行多次,数组中有几个元素就会执行几次,
                每次执行时都会将一个元素赋值给变量
      
    3数组的方法
        方法查询地址https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
        Array.isArray()
            - 用来检查一个对象是否是数组    
        Array.includes()
            -检查一个数组是否含有指定的值

        at()
            - 可以根据索引获取数组中的指定元素
            - at可以接收负索引作为参数
        concat()
            - 用来连接两个或多个数组
            - 非破坏性方法,不会影响原数组,而是返回一个新的数组

        indexOf()
            - 获取元素在数组中第一次出现的索引
            - 参数:
                1. 要查询的元素
                2. 查询的其实位置
        lastIndexOf()
            - 获取元素在数组中最后一次出现的位置

            - 返回值:
                找到了则返回元素的索引,
                没有找到返回-1

        join()
            - 将一个数组中的元素连接为一个字符串
            - ["孙悟空", "猪八戒", "沙和尚", "唐僧", "沙和尚"] -> "孙悟空,猪八戒,沙和尚,唐僧,沙和尚"
            - 参数:指定一个字符串作为连接符

        slice()
            - 用来截取数组(非破坏性方法)     
            - 参数:
                1. 截取的起始位置(包括该位置)
                2. 截取的结束位置(不包括该位置)   
                    - 第二个参数可以省略不写,如果省略则会一直截取到最后
                    - 索引可以是负值
                如果将两个参数全都省略,则可以对数组进行浅拷贝(浅复制)

        push()
            - 向数组的末尾添加一个或多个元素,并返回新的长度
        pop()
            - 删除并返回数组的最后一个元素
        unshift()
            - 向数组的开头添加一个或多个元素,并返回新的长度
        shift()
            - 删除并返回数组的第一个元素
        splice()
            - 可以删除、插入、替换数组中的元素
            - 参数:
                1. 删除的起始位置
                2. 删除的数量
                3. 要插入的元素

            - 返回值:
                - 返回被删除的元素
        reverse()
            - 反转数组

        sort()
            - sort用来对数组进行排序(会对改变原数组)
            - sort默认会将数组升序排列
                注意:sort默认会按照Unicode编码进行排序,所以如果直接通过sort对数字进行排序
                    可能会得到一个不正确的结果
            - 参数:
                - 可以传递一个回调函数作为参数,通过回调函数来指定排序规则
                    (a, b) => a - b 升序排列
                    (a, b) => b - a 降序排列
        forEach()
            - 用来遍历数组
            - 它需要一个回调函数作为参数,这个回调函数会被调用多次
                数组中有几个元素,回调函数就会调用几次
                每次调用,都会将数组中的数据作为参数传递
            - 回调函数中有三个参数:
                element 当前的元素
                index 当前元素的索引
                array 被遍历的数组

        filter()
            - 将数组中符合条件的元素保存到一个新数组中返回
            - 需要一个回调函数作为参数,会为每一个元素去调用回调函数,并根据返回值来决定是否将元素添加到新数组中
            - 非破坏性方法,不会影响原数组

        map()
            - 根据当前数组生成一个新数组
            - 需要一个回调函数作为参数,
                回调函数的返回值会成为新数组中的元素
            - 非破坏性方法不会影响原数组

        reduce()
            - 可以用来将一个数组中的所有元素整合为一个值
            - 参数:
                1. 回调函数,通过回调函数来指定合并的规则
                2. 可选参数,初始值

        find()
            数组的方法,语法arr.find((a)={关于a的表达式})
            用处,找出满足表达式的第一个元素,并且返回值为该元素
            如果该元素是个对象,修改返回的对象的属性和属性值将会影响到原数组
            
    4 浅拷贝和深拷贝
        浅拷贝(shallow copy)
            - 通常对对象的拷贝都是浅拷贝
            - 浅拷贝顾名思义,只对对象的浅层进行复制(只复制一层)
            - 如果对象中存储的数据是原始值,那么拷贝的深浅是不重要
            - 浅拷贝只会对对象本身进行复制,不会复制对象中的属性(或元素)
        对象的浅拷贝
            - Object.assign(目标对象, 被复制的对象)
            - 将被复制对象中的属性复制到目标对象里,并将目标对象返回
            - 也可以使用展开运算符对对象进行复制
            将obj中的属性在新对象中展开,原有属性名和新增属性名不相同时,不会修改原属性;如果有相同属性,则新属性会覆盖原有属性
            const obj3 = { address: "高老庄", ...obj, age: 48 }
        数组的浅拷贝
            使用 数组.slice()
            const arr = [{name:"孙悟空"}, {name:"猪八戒"}]
            const arr2 = arr.slice()
                    

        深拷贝(deep copy)
            深拷贝指不仅复制对象本身,还复制对象中的属性和元素
            - 因为性能问题,通常情况不太使用深拷贝
        对象的深拷贝
            利用JSON来完成深复制
            const str = JSON.stringify(obj)
            const obj4 = JSON.parse(str)
        
        数组的深拷贝
            方法structuredClone(arr)   列子const arr3 = structuredClone(arr)




    5...(展开运算符)
        - 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
        - 通过它也可以对数组进行浅复制
        - const arr3 = ["唐僧", ...arr, "白骨精"]  也可以在展开运算符两边加上需要添加的元素
    
    6this和函数调用
        根据函数调用方式的不同,this的值也不同:
            1. 以函数形式调用,this是window
            2. 以方法形式调用,this是调用方法的对象
            3. 构造函数中,this是新建的对象
            4. 箭头函数没有自己的this,由外层作用域决定
            5. 通过call和apply调用的函数,它们的第一个参数就是函数的this
            6. 通过bind返回的函数,this由bind第一个参数决定(无法修改)

        调用函数除了通过 函数() 这种形式外,还可以通过其他的方式来调用函数
        比如,我们可以通过调用函数的call()和apply()来个方法来调用函数
            函数.call()
            函数.apply()
            - call 和 apply除了可以调用函数,还可以用来指定函数中的this
            - call和apply的第一个参数,将会成为函数的this
            - 通过call方法调用函数,函数的实参直接在第一个参数后一个一个的列出来
            - 通过apply方法调用函数,函数的实参需要通过一个数组传递
        
        bind() 是函数的方法,可以用来创建一个新的函数
                - bind可以为新函数绑定this
                - bind可以为新函数绑定参数

            箭头函数没有自身的this,它的this由外层作用域决定,也无法通过call apply 和 bind修改它的this,箭头函数中没有arguments

17内建对象
    1解构赋值(数组)
        数组的解构赋值变量需要用[]
        声明变量之后解构赋值:const arr = ["孙悟空", "猪八戒", "沙和尚"],let a,b,c ;[a, b, c] = arr
        声明变量并且解构赋值: let [d, e, f, g] = ["唐僧", "白骨精", "蜘蛛精", "玉兔精"] 
        解构数组时,可以使用...来设置获取多余的元素let [n1, n2, ...n3] = [4, 5, 6, 7]
        可以通过解构赋值来快速交换两个变量的值:let a1 = 10；let a2 = 20;[a1, a2] = [a2, a1] 
        数组中可以存储任意类型的数据,也可以存数组,如果一个数组中的元素还是数组,则这个数组我们就称为是二维数组
    2解构赋值(对象)
        对象的解构赋值变量需要用{}
        对象解构需要变量名和对象的属性名一样,如果没有该属性,赋值将会返回underfunded
    3对象的序列化
        - JS中的对象使用时都是存在于计算机的内存中的
        - 序列化指将对象转换为一个可以存储的格式
            在JS中对象的序列化通常是将一个对象转换为字符串(JSON字符串)
        - 序列化的用途(对象转换为字符串有什么用):
            - 对象转换为字符串后,可以将字符串在不同的语言之间进行传递
                甚至人可以直接对字符串进行读写操作,使得JS对象可以不同的语言之间传递
            - 用途:
                1. 作为数据交换的格式
                2. 用来编写配置文字
        - 如何进行序列化:
            - 在JS中有一个工具类 JSON (JavaScript Object Notation) JS对象表示法
            - JS对象序列化后会转换为一个字符串,这个字符串我们称其为JSON字符串  
            
        - 也可以手动的编写JSON字符串,在很多程序的配置文件就是使用JSON编写的
        - 编写JSON的注意事项:
            1. JSON字符串有两种类型:
                JSON对象 {}
                JSON数组 []
            2. JSON字符串的属性名必须使用双引号引起来
            3. JSON中可以使用的属性值(元素)
                - 数字(Number)
                - 字符串(String) 必须使用双引号
                - 布尔值(Boolean)
                - 空值(Null)
                - 对象(Object {})
                - 数组(Array [])
            4. JSON的格式和JS对象的格式基本上一致的,
                注意:JSON字符串如果属性是最后一个,则不要再加,
    
    4Map
        - Map用来存储键值对结构的数据(key-value)
        - Object中存储的数据就可以认为是一种键值对结构
        - Map和Object的主要区别:
            - Object中的属性名只能是字符串或符号,如果传递了一个其他类型的属性名,
                JS解释器会自动将其转换为字符串
            - Map中任何类型的值都可以称为数据的key
        
        创建:
        new Map()

        属性和方法:
            map.size() 获取map中键值对的数量
            map.set(key, value) 向map中添加键值对
            map.get(key) 根据key获取值   
            map.delete(key) 删除指定数据
            map.has(key) 检查map中是否包含指定键
            map.clear() 删除全部的键值对
        
        将map转换为数组:
            const arr = Array.from(map) 得到 [["name","孙悟空"],["age",18]]
            或者const arr = [...map]
        
        遍历map使用for of,并且遍历可以直接解构
      
    5Set(集合)
        Set用来创建一个集合
        - 它的功能和数组类似,不同点在于Set中不能存储重复的数据

        - 使用方式:
        创建
        - new Set()
        - new Set([...])

        方法
        size 获取数量
        add() 添加元素
        has() 检查元素
        delete() 删除元素
        也可以直接展开赋值给一个数组 const arr = [...set]
    6Math
        - Math一个工具类
        - Math中为我们提供了数学运算相关的一些常量和方法
        - 常量:
            Math.PI 圆周率
        - 方法:
            Math.abs() 求一个数的绝对值
            Math.min() 求多个值中的最小值
            Math.max() 求多个值中的最大值
            Math.pow() 求x的y次幂
            Math.sqrt() 求一个数的平方根

            Math.floor() 向下取整
            Math.ceil() 向上取整
            Math.round() 四舍五入取整
            Math.trunc() 直接去除小数位
            Math.random() 生成一个0-1之间的随机数
    7Date
        - 在JS中所有的和时间相关的数据都由Date对象来表示
        - 对象的方法(使用 时间对象.方法调用):
        getFullYear() 获取4位年份
        getMonth() 返当前日期的月份(0-11)
        getDate() 返回当前是几日
        getDay() 返回当前日期是周几(0-6) 0表示周日
        ......
        getTime() 返回当前日期对象的时间戳
            时间戳:自1970年1月1日0时0分0秒到当前时间所经历的毫秒数
            计算机底层存储时间时,使用都是时间戳
        Date.now() 获取当前的时间戳
        let d = new Date() 直接通过new Date()创建时间对象时,它创建的是当前的时间的对象
            可以在Date()的构造函数中,传递一个表示时间的字符串
            字符串的格式:月/日/年 时:分:秒   年-月-日T时:分:秒
         
        时间的格式化方法
            toLocaleString()
            - 可以将一个日期转换为本地时间格式的字符串
            - 参数:
                1. 描述语言和国家信息的字符串
                    zh-CN 中文中国
                    zh-HK 中文香港
                    en-US 英文美国
                2. 需要一个对象作为参数,在对象中可以通过对象的属性来对日期的格式进行配置
                        dateStyle 日期的风格
                        timeStyle 时间的风格
                            full
                            long
                            medium
                            short
                        hour12 是否采用12小时值
                            true
                            false
                        weekday 星期的显示方式
                            long
                            short
                            narrow
                        year
                            numeric
                            2-digit
    
    8包装类
        在JS中,除了直接创建原始值外,也可以创建原始值的对象
        通过 new String() 可以创建String类型的对象
        通过 new Number() 可以创建Number类型的对象
        通过 new Boolean() 可以创建Boolean类型的对象
            - 但是千万不要这么做

        包装类:
        JS中一共有5个包装类
            String --> 字符串包装为String对象
            Number --> 数值包装为Number对象
            Boolean --> 布尔值包装为Boolean对象
            BigInt --> 大整数包装为BigInt对象
            Symbol --> 符号包装为Symbol对象
            - 通过包装类可以将一个原始值包装为一个对象,
                当我们对一个原始值调用方法或属性时,JS解释器会临时将原始值包装为对应的对象
                    然后调用这个对象的属性或方法
        - 由于原始值会被临时转换为对应的对象,这就意味着对象中的方法都可以直接通过原始值来调用
            
    9字符串:
    - 字符串其本质就是一个字符数组
    - "hello" --> ["h", "e", "l", "l", "o"]
    - 字符串的很多方法都和数组是非常类似的
    - 属性和方法:
        length 获取字符串的长度
        字符串[索引] 获取指定位置的字符
        str.at() (实验方法)
            - 根据索引获取字符,可以接受负索引
        str.charAt()
            - 根据索引获取字符
        str.concat()
            - 用来连接两个或多个字符串
        str.includes()
            - 用来检查字符串中是否包含某个内容
                有返回true
                没有返回false
        str.indexOf()
        str.lastIndexOf()
            - 查询字符串中是否包含某个内容
        str.startsWith()
            - 检查一个字符串是否以指定内容开头
        str.endsWith()
            - 检查一个字符串是否以指定内容结尾
        str.padStart()
        str.padEnd()
            - 通过添加指定的内容,使字符串保持某个长度
        str.replace()
            - 使用一个新字符串替换一个指定内容
        str.replaceAll()    
            - 使用一个新字符串替换所有指定内容
        str.slice()
            - 对字符串进行切片
        str.substring()
            - 截取字符串
        str.split()
            - 用来将一个字符串拆分为一个数组
        str.toLowerCase()
            - 将字符串转换为小写
        str.toUpperCase()
            - 将字符串转换为大写
        str.trim()
            - 去除前后空格
        str.trimStart()
            - 去除开始空格
        str.trimEnd()
            - 去除结束空格
        str.split()
            - 可以根据正则表达式来对一个字符串进行拆分
        str.search()
            - 可以去搜索符合正则表达式的内容第一次在字符串中出现的位置
        str.replace()
            - 根据正则表达式替换字符串中的指定内容
        str.match()
            - 根据正则表达式去匹配字符串中符合要求的内容
        str.matchAll()
            - 根据正则表达式去匹配字符串中符合要求的内容(必须设置g 全局匹配)
            - 它返回的是一个迭代器
    
    10正则表达式
        - 正则表达式用来定义一个规则
        - 通过这个规则计算机可以检查一个字符串是否符合规则
            或者将字符串中符合规则的内容提取出来
        - 正则表达式也是JS中的一个对象,
            所以要使用正则表达式,需要先创建正则表达式的对象
        new RegExp() 可以接收两个参数(字符串) 1.正则表达式 2.匹配模式
        let reg = new RegExp("a", "i") // 通过构造函数来创建一个正则表达式的对象
        使用字面量来创建正则表达式:/正则/匹配模式
        
        1.在正则表达式中大部分字符都可以直接写
            2.| 在正则表达式中表示或
            3.[] 表示或(字符集)
                [a-z] 任意的小写字母
                [A-Z] 任意的大写字母
                [a-zA-Z] 任意的字母
                [0-9]任意数字
            4.[^] 表示除了
                [^x] 除了x
            5. . 表示除了换行外的任意字符
            6. 在正则表达式中使用\作为转义字符
            7. 其他的字符集
                \w 任意的单词字符 [A-Za-z0-9_]
                \W 除了单词字符 [^A-Za-z0-9_]
                \d 任意数字 [0-9]
                \D 除了数字 [^0-9]
                \s 空格
                \S 除了空格
                \b 单词边界
                \B 除了单词边界
            8. 开头和结尾
                ^ 表示字符串的开头
                $ 表示字符串的结尾

            9.量词
                {m} 正好m个
                {m,} 至少m个
                {m,n} m-n个
                + 一个以上,相当于{1,}
                * 任意数量的a
                ? 0-1次 {0,1}

            10方法
            reg.test(str)
            通过正则表达式检查一个字符串是否符合规则,返回一个布尔值
            re.exec()
            - 获取字符串中符合正则表达式的内容,g表示全局匹配

    11垃圾回收(Garbage collection)
        - 和生活一样,生活时间长了以后会产生生活垃圾
            程序运行一段时间后也会产生垃圾
        - 在程序的世界中,什么是垃圾？
            - 如果一个对象没有任何的变量对其进行引用,那么这个对象就是一个垃圾
            - 垃圾对象的存在,会严重的影响程序的性能
            - 在JS中有自动的垃圾回收机制,这些垃圾对象会被解释器自动回收,我们无需手动处理
            - 对于垃圾回收来说,我们唯一能做的事情就是将不再使用的变量设置为null
    
18DOM
    1DOM简介
        要使用DOM来操作网页,我们需要浏览器至少得先给我一个对象,才能去完成各种操作,所以浏览器已经为我们提供了一个document对象,它是一个全局变量可以直接使用,document代表的是整个的网页
    
    2document对象
        - document对象表示的是整个网页
        - document对象的原型链
            HTMLDocument -> Document -> Node -> EventTarget -> Object.prototype -> null
        - 凡是在原型链上存在的对象的属性和方法都可以通过Document去调用
        - 部分属性:
            document.documentElement -- html根元素
            document.head -- head元素
            document.title -- title元素
            document.body -- body元素
            document.links -- 获取页面中所有的超链接
            ...
    
    3元素节点对象(element)
        - 在网页中,每一个标签都是一个元素节点
        - 如何获取元素节点对象？
            1. 通过document对象来获取元素节点
            2. 通过document对象来创建元素节点
        - 通过document来获取已有的元素节点:
            document.getElementById()
                - 根据id获取一个元素节点对象
            document.getElementsByClassName()
                - 根据元素的class属性值获取一组元素节点对象
                - 返回的是一个类数组对象
                - 该方法返回的结果是一个实时更新的集合
                    当网页中新添加元素时,集合也会实时的刷新
            document.getElementsByTagName()
                - 根据标签名获取一组元素节点对象
                - 返回的结果是可以实时更新的集合
                - document.getElementsByTagName("*") 获取页面中所有的元素
            document.getElementsByName()
                - 根据name属性获取一组元素节点对象
                - 返回一个实时更新的集合
                - 主要用于表单项
            document.querySelectorAll()
                - 根据CSS选择器去页面中查询元素
                - 会返回一个类数组(不会实时更新)
            document.querySelector()
                - 根据选择器去页面中查询第一个符合条件的元素

        - 创建一个元素节点
            document.createElement()
                - 根据标签名创建一个元素节点对象
    
        - div元素的原型链
            HTMLDivElement -> HTMLElement -> Element -> Node -> ...

        - 通过元素节点对象获取其他节点的方法
            element.childNodes 获取当前元素的子节点(会包含空白的子节点)
            element.children 获取当前元素的子元素
            element.firstElementChild 获取当前元素的第一个子元素
            element.lastElementChild 获取当前元素的最后一个子元素
            element.nextElementSibling 获取当前元素的下一个兄弟元素
            element.previousElementSibling 获取当前元素的前一个兄弟元素
            element.parentNode 获取当前元素的父节点
            element.tagName 获取当前元素的标签名
            
    4文本节点
        在DOM中,网页中所有的文本内容都是文本节点对象,
            可以通过元素来获取其中的文本节点对象,但是我们通常不会这么做
            我们可以直接通过元素去修改其中的文本
            修改文本的三个属性
                element.textContent 获取或修改元素中的文本内容
                    - 获取的是标签中的内容,不会考虑css样式

                element.innerText 获取或修改元素中的文本内容
                    - innerText获取内容时,会考虑css样式
                    - 通过innerText去读取CSS样式,会触发网页的重排(计算CSS样式)
                    - 当字符串中有标签时,会自动对标签进行转义
                    - <li> --> &lt;li&gt;

                element.innerHTML 获取或修改元素中的html代码
                    - 可以直接向元素中添加html代码
                    - innerHTML插入内容时,有被xss注入的风险

    5属性节点(Attr)
        - 在DOM也是一个对象,通常不需要获取对象而是直接通过元素即可完成对其的各种操作
        - 如何操作属性节点:
            方式一:
                读取:元素.属性名(注意,class属性需要使用className来读取)
                        读取一个布尔值时,会返回true或false
                修改:元素.属性名 = 属性值

            方式二:
                读取:元素.getAttribute(属性名)
                修改:元素.setAttribute(属性名, 属性值)
                删除:元素.removeAttribute(属性名)

    6事件(event)
        - 事件就是用户和页面之间发生的交互行为
            比如:点击按钮、鼠标移动、双击按钮、敲击键盘、松开按键...  
        - 可以通过为事件绑定响应函数(回调函数),来完成和用户之间的交互
        - 绑定响应函数的方式:
            1.可以直接在元素的属性中设置
            2.可以通过为元素的指定属性设置回调函数的形式来绑定事件(一个事件只能绑定一个响应函数)
            3.可以通过元素addEventListener()方法来绑定事件
                        
        获取到按钮对象
        const btn = document.getElementById("btn")
        为按钮对象的事件属性设置响应函数
        btn.onclick = function(){
        alert("我又被点了一下~~")}

    7文档的加载
        网页是自上向下加载的,如果将js代码编写到网页的上边,
        js代码在执行时,网页还没有加载完毕,这时会出现无法获取到DOM对象的情况
        window.onload 事件会在窗口中的内容加载完毕之后才触发
        document的DOMContentLoaded事件会在当前文档加载完毕之后触发
        如何解决这个问题:
            1. 将script标签编写到body的最后(*****)
            2. 将代码编写到window.onload的回调函数中
            3. 将代码编写到document对象的DOMContentLoaded的回调函数中(执行时机更早)
            4. 将代码编写到外部的js文件中,然后以defer的形式进行引入(会在所有代码执行完毕之后加载,但是比DOMContentLoaded执行时机更早)(*****)

    8DOM的修改
        appendChild() 用于给一个节点添加子节点
        insertAdjacentElement()可以向元素的任意位置添加元素
            两个参数:1.要添加的位置 2.要添加的元素
            beforeend 标签的最后
            afterbegin 标签的开始
            beforebegin 在元素的前边插入元素(兄弟元素)
            afterend 在元素的后边插入元素(兄弟元素)
            list.insertAdjacentElement("afterend", li)
        示例:list.insertAdjacentHTML("beforeend", "<li id='bgj'>白骨精</li>")

        修改属性的方法
            const li = document.createElement("li")
            li.textContent = "蜘蛛精"   修改文本
            li.id = "zzj"              修改ID
            remove()方法用来删除当前元素
            swk.replaceWith(li) 使用一个元素替换当前元素
    
    9节点的复制
        const newL1 = l1.cloneNode(true) // 用来对节点进行复制的
        使用 cloneNode() 方法对节点进行复制时,它会复制节点的所有特点包括各种属性,这个方法默认只会复制当前节点,而不会复制节点的子节点,可以传递一个true作为参数,这样该方法也会将元素的子节点一起复制
    
    10修改css样式
        修改样式的方式:元素.style.样式名 = 样式值
        如果样式名中含有-,则需要将样式表修改为驼峰命名法
        background-color --> backgroundColor

        除了直接修改样式外,也可以通过修改class属性来间接的修改样式
        通过class修改样式的好处:
            1. 可以一次性修改多个样式
            2. 对JS和CSS进行解耦
        box1.className += " box2"  字符串拼串的方式加入新的class属性

        元素.classList 是一个对象,对象中提供了对当前元素的类的各种操作方法
            元素.classList.add() 向元素中添加一个或多个class
            元素.classList.remove() 移除元素中的一个或多个class
            元素.classList.toggle() 切换元素中的class
            元素.classList.replace() 替换class
            元素.classList.contains() 检查class

    11读取css的样式
        getComputedStyle()
        - 它会返回一个对象,这个对象中包含了当前元素所有的生效的样式
        - 参数:
            1. 要获取样式的对象
            2. 要获取的伪元素
        - 返回值:
            返回的一个对象,对象中存储了当前元素的样式
        - 注意:
            样式对象中返回的样式值,不一定能来拿来直接计算
                所以使用时,一定要确保值是可以计算的才去计算

    12读取其他样式
        元素.clientHeight
        元素.clientWidth
            - 获取元素内部的宽度和高度(包括内容区和内边距)

        元素.offsetHeight
        元素.offsetWidth
            - 获取元素的可见框的大小(包括内容区、内边距和边框)

        元素.scrollHeight
        元素.scrollWidth
            - 获取元素滚动区域的大小

        元素.offsetParent
            - 获取元素的定位父元素
            - 定位父元素:离当前元素最近的开启了定位的祖先元素,
                如果所有的元素都没有开启定位则返回body

        元素.offsetTop
        元素.offsetLeft
            - 获取元素相对于其定位父元素的偏移量

        元素.scrollTop
        元素.scrollLeft
            - 获取或设置元素滚动条的偏移量

    13事件对象(event)
        - 事件对象是有浏览器在事件触发时所创建的对象,
        这个对象中封装了事件相关的各种信息
        - 通过事件对象可以获取到事件的详细信息
        比如:鼠标的坐标、键盘的按键..
        - 浏览器在创建事件对象后,会将事件对象作为响应函数的参数传递,
        所以我们可以在事件的回调函数中定义一个形参来接收事件对象

        在DOM中存在着多种不同类型的事件对象
            - 多种事件对象有一个共同的祖先 Event
                - event.target 触发事件的对象
                - event.currentTarget 绑定事件的对象(同this)
                - event.stopPropagation() 停止事件的传导
                - event.preventDefault() 取消默认行为
                - this 绑定事件的对象

        - 事件的冒泡(bubble)
            - 事件的冒泡就是指事件的向上传到
            - 当元素上的某个事件被触发后,其祖先元素上的相同事件也会同时被触发
            - 冒泡的存在大大的简化了代码的编写,但是在一些场景下我们并不希望冒泡存在
                不希望事件冒泡时,可以通过事件对象来取消冒泡
    
    14事件的传播机制
        - 在DOM中,事件的传播可以分为三个阶段:
            1.捕获阶段 (由祖先元素向目标元素进行事件的捕获)(默认情况下,事件不会在捕获阶段触发)
            2.目标阶段 (触发事件的对象)
            3.冒泡阶段 (由目标元素向祖先元素进行事件的冒泡)

        - 事件的捕获,指事件从外向内的传导,
            当前元素触发事件以后,会先从当前元素最大的祖先元素开始向当前元素进行事件的捕获

        - 如果希望在捕获阶段触发事件,可以将addEventListener的第三个参数设置为true
            一般情况下我们不希望事件在捕获阶段触发,所有通常都不需要设置第三个参数

        event.eventPhase 表示事件触发的阶段
        1 捕获阶段 2 目标阶段 3 冒泡阶段
           
19BOM
    - 浏览器对象模型
    - BOM为我们提供了一组对象,通过这组对象可以完成对浏览器的各种操作
    - BOM对象:
        - Window —— 代表浏览器窗口(全局对象)
        - Navigator —— 浏览器的对象(可以用来识别浏览器)
        - Location —— 浏览器的地址栏信息
        - History —— 浏览器的历史记录(控制浏览器前进后退)
        - Screen —— 屏幕的信息

    - BOM对象都是作为window对象的属性保存的,所以可以直接在JS中访问这些对象

    1Navigator —— 浏览器的对象(可以用来识别浏览器)
        userAgent 返回一个用来描述浏览器信息的字符串
    
    2 location 表示的是浏览器地址栏的信息
        - 可以直接将location的值修改为一个新的地址,这样会使得网页发生跳转
        - location.assign() 跳转到一个新的地址
        - location.replace() 跳转到一个新的地址(无法通过回退按钮回退)
        - location.reload() 刷新页面,可以传递一个true来强制清缓存刷新
        - location.href 获取当前地址
    
    3history
        history.back()
            - 回退按钮
        history.forward()
            - 前进按钮
        history.go()
            - 可以向前跳转也可以向后跳转
        
    4通过定时器,可以使代码在指定时间后执行
        - 设置定时器的方式有两种:
            setTimeout()
                - 参数:
                    1. 回调函数(要执行的代码)
                    2. 间隔的时间(毫秒)
                - 关闭定时器
                    clearTimeout()

            setInterval() (每间隔一段时间代码就会执行一次)
                - 参数:
                    1. 回调函数(要执行的代码)
                    2. 间隔的时间(毫秒)
                - 关闭定时器
                    clearInterval()

        定时器的本质,就是在指定时间后将函数添加到消息队列中
        setInterval() 没间隔一段时间就将函数添加到消息队列中
        但是如果函数执行的速度比较慢,它是无法确保每次执行的间隔都是一样的
        
    5事件循环(event loop)
        - 函数在每次执行时,都会产生一个执行环境
        - 执行环境负责存储函数执行时产生的一切数据
        - 问题:函数的执行环境要存储到哪里呢？
            - 函数的执行环境存储到了一个叫做调用栈的地方
            - 栈,是一种数据结构,特点 后进先出

        调用栈(call stack)
            - 调用栈负责存储函数的执行环境
            - 当一个函数被调用时,它的执行环境会作为一个栈帧
                插入到调用栈的栈顶,函数执行完毕其栈帧会自动从栈中弹出
    
        - 函数在每次执行时,都会产生一个执行环境
        - 执行环境负责存储函数执行时产生的一切数据
        - 问题:函数的执行环境要存储到哪里呢？
            - 函数的执行环境存储到了一个叫做调用栈的地方
            - 栈,是一种数据结构,特点 后进先出
            - 队列,是一种数据结构,特点 先进先出
        
        调用栈(call stack)
            - 调用栈负责存储函数的执行环境
            - 当一个函数被调用时,它的执行环境会作为一个栈帧
                插入到调用栈的栈顶,函数执行完毕其栈帧会自动从栈中弹出

        消息队列
            - 消息队列负责存储将要执行的函数
            - 当我们触发一个事件时,其响应函数并不是直接就添加到调用栈中的
                因为调用栈中有可能会存在一些还没有执行完的代码
            - 事件触发后,JS引擎是将事件响应函数插入到消息队列中排队

    